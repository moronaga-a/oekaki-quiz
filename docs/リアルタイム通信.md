# リアルタイム通信
Action Cable（WebSocket）を使ったリアルタイム通信の動作フロー

---

## 1. WebSocket接続の確立（1回だけ、準備）

**何をしている？**
- プレイヤーがルームに参加した時、ブラウザとサーバーをWebSocketで接続
- サーバーは「ルームABC123専用のストリーム（配信チャンネル）」にこのプレイヤーを登録
- これで、ルームABC123で起きた出来事（描画、チャット等）が自動的にこのプレイヤーに配信される

```mermaid
sequenceDiagram
    participant Client as クライアント<br/>(Stimulus Controller)
    participant Server as サーバー<br/>(GameChannel)
    participant Stream as 📻 ストリーム<br/>(Room ABC123)
    participant Others as 他のクライアント

    Note over Client,Server: Action Cable (WebSocket通信)

    Note over Client,Others: ページ読み込み時（ルーム参加時）

    Client->>Server: ① subscriptions.create()<br/>WebSocket接続開始
    Note over Server: GameChannel#subscribed

    Server->>Stream: ② stream_from "game_channel_ABC123"<br/>ストリームに登録
    Note over Stream: Room ABC123の<br/>配信チャンネル作成

    Server->>Client: ③ connected()
    Client->>Client: connectionStatus = 'connected'

    Note over Client,Others: 接続完了！<br/>以降、このストリームで配信される
```

---

## 2. 共通の通信パターン（すべてのイベントで同じ、通信のたびに何度も行う）

**何をしている？**
- プレイヤーがアクション（描画、チャット等）を行うと、WebSocket経由でサーバーに送信
- サーバーは処理を実行し、結果を「ルームのストリーム」にブロードキャスト
- ストリームに登録されている全プレイヤーに自動配信され、各自のUIが更新される

```mermaid
sequenceDiagram
    participant Client as クライアント<br/>(Stimulus Controller)
    participant Server as サーバー<br/>(GameChannel)
    participant Stream as 📻 ストリーム<br/>(Room ABC123)
    participant Others as 他のクライアント

    Note over Client,Server: Action Cable (WebSocket通信)

    Note over Client,Others: 【共通の通信パターン】

    Note over Client: ① イベント発生
    Client->>Server: ② perform('draw', data)
    Note over Server: ③ GameChannel#draw(data)<br/>ビジネスロジック実行

    Note over Server: ④ ストリームに配信
    Server->>Stream: broadcast("game_channel_ABC123", result)
    Note over Stream: Room ABC123の<br/>ストリーム経由で配信

    Stream-->>Client: ⑤ WebSocket push
    Stream-->>Others: ⑤ WebSocket push

    Note over Client,Others: ⑥ UI更新
    Client->>Client: received(data)
    Others->>Others: received(data)
```

**ポイント:** Canvas描画、チャット、プレイヤー参加、ゲーム状態など、**すべてのイベントがこの同じ流れ**で処理されます。違うのはデータの中身（`data.type`）だけです。

---

## ストリームとは？

**ストリーム = ルーム専用の配信チャンネル（放送局のようなもの）**

```mermaid
flowchart TD
    GameChannel[GameChannel<br/>subscribed]

    Stream1[📻 ストリーム<br/>Room ABC123]
    Stream2[📻 ストリーム<br/>Room XYZ789]

    A[Player A]
    B[Player B]
    C[Player C]

    D[Player D]
    E[Player E]

    GameChannel -->|stream_for room| Stream1
    GameChannel -->|stream_for room| Stream2

    Stream1 -.購読中.-> A
    Stream1 -.購読中.-> B
    Stream1 -.購読中.-> C

    Stream2 -.購読中.-> D
    Stream2 -.購読中.-> E

    Note1[broadcast_to ABC123]
    Note1 --> Stream1
    Note1 -.配信.-> A
    Note1 -.配信.-> B
    Note1 -.配信.-> C

    style Stream1 fill:#FFE4B5
    style Stream2 fill:#E0FFE0
    style Note1 fill:#FFB6C1
```

---

## まとめ

### Action Cableの基本フロー
```
【図1: 接続確立（1回）】
接続確立 (subscribed)
    ↓
📻 ストリーム登録 (stream_for room)  ← ここで放送局に加入
    ↓
接続完了

【図2: 通信パターン（何度も）】
イベント送信 (perform)
    ↓
サーバー処理 (GameChannel)
    ↓
📻 ストリームに配信 (broadcast_to)  ← ここで放送局経由で配信
    ↓
全プレイヤー受信 (received)
    ↓
UI更新
```

### ルーム分離の仕組み
```
GameChannel
  └── stream_for room
       ├── Room ABC123 (独立したストリーム)
       │    ├── Player A
       │    ├── Player B
       │    └── Player C
       └── Room XYZ789 (独立したストリーム)
            ├── Player D
            └── Player E
```

### パフォーマンス特性
```
Action Cable:
  - レイテンシ: 50-200ms (中程度)
  - 適用範囲: チャット、状態同期、通知
  - 制約: 高頻度更新は不得意

Socket.io:
  - レイテンシ: 10-50ms (低い)
  - 適用範囲: リアルタイムゲーム、描画同期
  - 制約: 別サーバーが必要
```

### ステートマシンとの連携
```
GameState (モデル層)
  status: :waiting → :playing → :finished
          ↓          ↓          ↓
    broadcast  broadcast  broadcast
          ↓          ↓          ↓
    Action Cable で全プレイヤーに配信
          ↓          ↓          ↓
    全員のUIが同じ状態に更新される
```
